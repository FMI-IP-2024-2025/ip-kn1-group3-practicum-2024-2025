# Указатели и псевдоними (pointers and references)

Указатели ;) към съответните секции:

- [указатели](#указатели)
- [псевдоними (референции)](#псевдонимите-са-сравнително-подобни-по-функционалност-на-указателите-с-няколко-важни-разлики)

# Указатели

### Указателите са променливи, които съдържат адрес в паметта.
За да декларираме указател, трябва да укажем типа, към който той "сочи".

```c++
<тип>* ptr;
```

Различимата стойност при указателите е `nullptr`. Тя може да бъде както много полезна, така и много коварна. :D Евентуално ще разберете защо.

```c++
char* cptr = nullptr;
double* dptr = nullptr;
```

### Адреси на променливи и дереференциране на указатели

Можем да взимаме адресите на променливите ни (т.е. къде се намират в паметта), използвайки оператора `&` пред името на променливата. Обратно, можем да извлечем стойността от даден адрес в паметта с помощта на оператора `*` пред името на променливата.

```c++
int a = 10;
int* ptr = &a; //записваме адреса на а в ptr
int b = *ptr; //извличаме стойността от адреса, към който сочи ptr
```

**NB!!!**: Дереференцирането на `nullptr` би означавало, че искаме да извлечем и евентуално модифицираме стойност на невалиден адрес и е недефинирано поведение.

### Константни указатели и указатели, сочещи към "константи"

Можем да имаме указатели, които сочат към някаква константна стойност:

```c++
int a = 10;
//двете неща са еквивалентни
const int* ptr1 = &a;
int const* ptr2 = &a; 
```

Това забранява да променяме стойността на `a` **чрез указателите `ptr1` и `ptr2`**. Тоест,

```c++
int a = 10;
int const* ptr = &a;
*ptr = 11;  //невалидно!!!
a = 11;  //ок
```

Забележете, че няма нужда променливата, към която сочи указателят, да е константа.

Както знаем, можем да декларираме и самите променливи като `const`. Същото можем да постигнем и с указатели:

```c++
int a = 10;
int* const ptr = &a;
```

Тук вече **самият указател** е константен - т.е. адресът, който съдържа, не може да бъде променян. Тоест,

```c++
int a = 10, b = 11;
int* const ptr = &a;
ptr = &b;  //невалидно!!!
*ptr = b;  //ок, присвояваме стойността на b на това, към което сочи ptr
```

#### Правилото е съответните типове да се четат от дясно наляво:

```c++
int* ptr; //указател към променлива от тип int
int const* ptr; //указател към константа от тип int
int* const ptr = ...; //константен указател към променлива от тип int
int const* const ptr = ...; //константен указател към константа от тип int
```

### Размер на указателите

Размерът на указателите може да варира между различните архитектури. По принцип съвпада с размера на машинната дума - т.е. на 64-битови архитектури е 8 байта, независимо от типа, към който сочи.

```c++
assert(sizeof(void*) == 8);
assert(sizeof(int*) == 8);
assert(sizeof(char**) == 8);
```

### Един пример, където бихме могли да използваме указатели

Можем директно да модифицираме стойностите на променливите, подадени като параметри на функции чрез указатели:

```c++
void swap(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}
```

Този пример не е особено добър, тъй като позволяваме `a` или `b` да са `nullptr` - ще се опитаме да дереференцираме `nullptr`.

## Указателна аритметика

Досега не сме уточнявали как работи индексирането в C++:

```c++
int arr[] {1,5,3,4};
arr[1] = 2; 
```

Идеята се състои в това, че масивите всъщност "съдържат" указател, който сочи към първия елемент на масива. Тоест,

```c++
assert(arr == &arr[0]);
```

идентификаторът на масива може да се разглежда като указател към първия му елемент.

*Забележка*: Това не означава, че масиви и указатели са взаимнозаменяеми понятия. Понякога масивите могат да се разглеждат като указатели (както в по-горе описания пример) - това е т.нар. [*array-to-pointer type decay*](#array-to-pointer-type-decay). Но в общия случай за нас масивът е последовалност от елементи от даден тип в паметта, а указателят е променлива, която сочи към нещо от даден тип в паметта. 

Зад индексацията стои отместване с определен брой **елементи** именно от този указател.

```c++
arr[0] == *(arr+0) == *arr
arr[1] == *(arr+1)
...
//отместваме се с i на брой елементи от arr
arr[i] == *(arr+i)
```

Забележете, че пишем не с колко байта се отместваме, а с колко **елемента**. Де факто се случва имплицитно умножение на броя елементи `i` по размера на типа, от който са елементите на масива (`i*sizeof(<тип>)`). Ние **не** пишем това.

## Array-to-pointer type decay

Ако се опитаме да напишем следните дефиниции на функции в един и същи файл,

```c++
void foo(int arr[]) {}
void foo(int arr[100]) {}
void foo(int* arr) {}
```

ще получим компилационни грешки - `error: redefinition of 'void foo(int*)'` (и др.). Причината за това е, че тези три сигнатури на функции са **едни и същи** - и трите се свеждат до `void foo(int* arr)`. Това е причината да подаваме и размера на даден масив, когато го подаваме като параметър на функция.

*Забележка*: Това феномен се случва **само в определени ситуации**. Една от тях е предаването на масиви като параметри на функции. В другите случаи, познати ни досега, това **не** се случва.

# Псевдоними (референции)

Псевдонимите, или още референции, са променливи, които се свързват с **друга променлива**. За тях можем да си мислим като за "друго име" на дадена променлива, тъй като не се извършва копиране по стойност.

### Псевдонимите са сравнително подобни по функционалност на указателите, с няколко важни разлики:

- #### нямаме различима стойност;

- #### не работим директно с адреси.

Какво означава това? Както видяхме, различима стойност при указателите ни е `nullptr`. При псевдонимите нямаме такава - причината е, че псевдонимите винаги се свързват с някаква променлива.

## Дефиниране на псевдоними

**Не можем** да декларираме псевдоними - при създаването си те винаги трябва да са свързани с някаква променлива.

```c++
int a = 10;
int& b = a;
```
Ако променим стойността на псевдонима, то ще променим стойността и на променливата, с която е свързан този псевдоним:

```c++
int a = 10;
int& b = a;
b = 11;  //a също е равно на 11!
```

**Не можем** да променяме променливата, с която е свързан псевдонимът. Тоест,

```c++
int a = 10, b = 11;
int& c = a;
c = b;  //присвоява се стойността на b на c
c = 12;
std::cout << b;  //стойността на b не се е променила!
```

все едно сме написали `T& const` (което не е валиден синтаксис!).

Забележете, че има разлика между "константен псевдоним" и "псевдоним към константа" - първото е винаги изпълнено. Под "псевдоним към константа" няма да разбираме псевдоним към нещо от вида `<тип> const`, а че няма да можем да променяме стойността на променливата/константата, с която е свързан псевдонимът, чрез самия псевдоним. Тоест,

```c++
int a = 10;
int const& b = a;
b = 11;  //невалидно!
a = 11;  //ок
```

Иначе казано, ако искаме да направим съпоставка между указатели и псевдоними,

```c++
int a = 10;

int* b = &a;              ~> няма еквивалент
int* const c = &a;        ~> int& c = a;
int const* d = &a;        ~> няма еквивалент
int const* const e = &a;  ~> int const& e = a;
```

### Някои особености при псевдонимите

- При създаване на псевдоним **не се копира стойността/обектът**, с който е свързан псевдонимът;

- Константен псевдоним **можем** да свързваме с литерал:

```c++
int& a = 12;  //невалидно! отдясно трябва да стои lvalue
int const& b = 12;  //ок
```

Тук имплицитно се създава **нова** променлива със стойност 12 и `b` се свързва именно с нея.

### Приложение на псевдонимите

Можем да напишем по-горната [функция](#един-пример-където-бихме-могли-да-използваме-указатели), използвайки псевдоними:

```c++
void swap(int& a, int& b) {
  int temp = a;
  a = b;
  b = temp;
}
```

Това е сравнително по-четимо, тъй като не се налага никъде да дереференцираме указатели, а и е по-безопасно, тъй като няма как да подадем `nullptr` на тази функция - стойностите, които подаваме на функцията, винаги трябва да са lvalues.

## TL;DR

#### Основно ще използваме указатели в следните случаи:

- искаме директно да модифицираме стойността на променлива, към която сочи даден указател.

- подаване на масив като параметър на функция;

- когато искаме да имаме различима стойност при указателите (`nullptr`);

#### Ще използваме псевдоними в следните случаи:

- искаме директно да модифицираме стойността на дадена променлива, която е свързана с псевдонима;

- `T const&` - не искаме да променяме нищо в даден обект и реферираме голяма структура от данни (повече за това по ООП);

- предефиниране на оператори (отново, повече за това по ООП).

## `*` и `&`

- `*` и `&` след някакъв тип обозначават декларация на променлива от съответния тип;
- `*` и `&` преди идентификатор дереференцират или връщат адреса на променливата с този идентификатор, респективно.

```c++
<тип>* ptr; //декларира указател към <тип>
<тип>& ref = <променлива>; //декларира референция към <променлива> от <тип>
*ptr; //дереференцира указателя
&<променлива>; //взима адреса на <променлива> 
```