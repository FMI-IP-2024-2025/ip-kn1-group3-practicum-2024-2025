# Указатели (pointers) - теория

### Указателите са променливи, които съдържат адрес в паметта. Най-често това са адреси на някакви променливи.

За да дефинираме указател, трябва да укажем типа, към който той "сочи".

```c++
<тип>* ptr;
```

Различимата стойност при указателите е `nullptr`. Тя може да бъде както много полезна, така и много коварна. :D Евентуално ще разберете защо.

### Адреси на променливи и дереференциране на указатели

Можем да взимаме адресите на променливите ни (т.е. къде се намират в паметта), използвайки оператора `&` пред името на променливата. Обратно, можем да извлечем стойността от даден адрес в паметта с помощта на оператора `*` пред името на променливата.

```c++
int a = 10;
int* ptr = &a; //записваме адреса на а в ptr
int b = *ptr; //извличаме стойността от адреса, към който сочи ptr
```

**NB!!!**: Дереференцирането на `nullptr` би означавало, че искаме да извлечем и евентуално модифицираме стойност на невалиден адрес и е недефинирано поведение.

### Константни указатели и указатели, сочещи към константни стойности

Можем да имаме указатели, които сочат към някаква константна стойност:

```c++
int a = 10;
//двете неща са еквивалентни
const int* ptr1 = &a;
int const* ptr2 = &a; 
```

Това забранява да променяме стойността на `a` **чрез указателите `ptr1` и `ptr2`**. Тоест,

```c++
int a = 10;
int const* ptr = &a;
*ptr = 11;  //невалидно!!!
a = 11;  //ок
```

Както знаем, можем да декларираме и самите променливи като `const`. Същото можем да постигнем и с указатели:

```c++
int a = 10;
int* const ptr = &a;
```

Тук вече **самият указател** е константен - т.е. адресът, който съдържа, не може да бъде променян. Тоест,

```c++
int a = 10, b = 11;
int* const ptr = &a;
ptr = &b;  //невалидно!!!
*ptr = b;  //ок, присвояваме стойността на b на това, към което сочи ptr
```

### Размер на указателите

Размерът на указателите може да варира между различните архитектури. По принцип съвпада с размера на машинната дума - т.е. на 64-битови архитектури е 8 байта, независимо от типа, към който сочи.

```c++
assert(sizeof(void*) == 8);
assert(sizeof(int*) == 8);
assert(sizeof(char**) == 8);
```

### Един пример, където бихме могли да използваме указатели

Можем директно да модифицираме стойностите на променливите, подадени като параметри на функции чрез указатели:

```c++
void swap(int* a, int* b) {
  int temp = *a;
  *a = *b;
  *b = temp;
}
```

Този пример не е особено добър, тъй като позволяваме `a` или `b` да са `nullptr` - ще се опитаме да дереференцираме `nullptr`. Как да избегнем този проблем, ще разберем, когато вземем псевдоними.

## Указателна аритметика

Досега не сме уточнявали как работи индексирането в C++:

```c++
int arr[] = {1,5,3,4};
arr[1] = 2; 
```

Идеята се състои в това, че масивите всъщност "съдържат" указател, който сочи към първия елемент на масива. Тоест,

```c++
assert(arr == &arr[0]);
```

Зад индексацията стои отместване с определен брой **елементи** именно от този указател.

```c++
arr[0] == *(arr+0) == *arr
arr[1] == *(arr+1)
...
//отместваме се с i на брой елементи от arr
arr[i] == *(arr+i)
```

Забележете, че пишем не с колко байта се отместваме, а с колко **елемента**. Де факто се случва имплицитно умножение на броя елементи `i` по размера на типа, от който са елементите на масива (`i*sizeof(<тип>)`). Ние **не** пишем това.