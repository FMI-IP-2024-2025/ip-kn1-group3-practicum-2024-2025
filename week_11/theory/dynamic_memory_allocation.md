# Работа с динамична памет

### Преди да започнете да четете това, е добре да си припомните [указатели и референции (псевдоними)](pointers_references.md).

## Защо динамична памет?

Динамичната памет (т.нар. *heap*) е отделен вид памет, където можем "динамично" да заделяме памет за обекти от различен вид типове данни. Това се извършва **по време на изпълнение на програмата**. Основно ще заделяме памет динамично, когато:

- не знаем предварително размера на даден обект по време на компилация;

- работим с голяма структура от данни.

## Заделяне на динамична памет

Заделянето на динамична памет се извършва чрез оператора `new`:

- за примитивни типове данни:

```c++
//не инициализираме цялото число, към което сочи ptr, с конкретна стойност
int* ptr = new int; 
//инициализираме това цяло число с 10
int* ptr2 = new int(10);
```

- за съставни типове данни:

```c++
//динамично заделяне на масив с 10 елемента
int* arr = new int[10];
```

## Освобождаване на динамично заделена памет

След като сме заделили памет динамично и вече нямаме нужда от нея, трябва да я **освободим**. В противен случай тази памет ще продължи да бъде "запазена" и няма да можем да я преизползваме:

- за примитивни типове данни:

```c++
delete ptr;
```

- за съставни типове данни:

```c++
delete[] arr;
```

## Особености при освобождаване на памет

- освобождаване на памет, която се сочи от `nullptr` - напълно легално действие в C++:

```c++
int* ptr = nullptr;
delete ptr;  //ок
```

```c++
int* ptr = nullptr;
delete[] ptr;  //ок
```

- двойно освобождаване на памет - това е **недефинирано поведение**:

```c++
int* ptr = new int(10);
delete ptr;  //освобождаваме паметта, към която сочи ptr
//some code...
delete ptr;  //паметта вече е освободена!
//опитваме се да освободим вече освободена памет
```

```c++
int* arr = new int[10];
delete[] arr;
//some more code...
delete[] arr;  //същият проблем като по-горе
```

### Забележка: операторът `delete` *не трие нищо*. Когато извикаме `delete` над някакъв обект, се извиква неговия деструктор (повече за това по ООП) и предишно заделената за него памет се връща обратно към свободната за алокации такава (т.нар. деалокация).

# Примери

- статичен масив от указатели

```c++
int* arr[10] {};
for (int i = 0; i < 10; ++i) {
  arr[i] = new int(i+1);  //заделяне на памет и инициализация
}
for (int i = 0; i < 10; ++i) {
  delete arr[i];  //освобождаване на памет
}
```

- динамичен масив от указатели

```c++
int** arr = new int*[10];
for (int i = 0; i < 10; ++i) {
  arr[i] = new int(i+1);
}
for (int i = 0; i < 10; ++i) {
  delete arr[i];
}
delete[] arr;
```

- динамичен масив от динамични масиви (матрица)

```c++
int** matrix = new int*[10];
for (int i = 0; i < 10; ++i) {
  matrix[i] = new int[i+1];
  for (int j = 0; j < i+1; ++j) {
    matrix[i][j] = j+1;
  }
}
for (int i = 0; i < 10; ++i) {
  delete[] matrix[i];
}
delete[] matrix;
```