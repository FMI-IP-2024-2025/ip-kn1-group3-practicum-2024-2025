# Низове - теория

### Низовете представляват поредица от символи. Съответно можем да ги кодираме по два основни начина:

#### - Низовете се представят чрез масиви от символи (`char`), които съдържат специален символ, наречен терминираща нула - `'\0'`. Както името подсказва, тя бележи *края* на низа (не обезателно на самия масив!).

#### - Низовете могат също така да се представят и чрез указател към `char`.

Дефинираме низове по следните начини (като те са еквивалентни, просто първото е по-четимо и по-лесно за писане):

```c++
char str1[] = "Hello!";  //тук не пишем '\0'!
char str2[] = {'H','e','l','l','o','!','\0'};
char const* str3 = "Hello!";
```

## Дължина vs. размер на низ

Дължина на един низ наричаме броя на значимите символи в низа. Например:

```
"Hello, world"  -> 12
```

Размер на низ наричаме дължината плюс символът за терминираща нула.

```
"Hello, world"  -> 13 заради имплицитната терминираща нула
```

## Стандартен вход и изход на низове

Можем да извеждаме низове на конзолата по следния начин:
```c++
char str[] = "Hello, world!";
std::cout << str;
```

Можем да приемаме низове като вход от конзолата по няколко начина:

```c++
char str1[129];  //128 значими символа + 1 за '\0'
//четенето спира при въвеждане на ' ', '\t', '\n'
//четат се 128 символа от конзолата
//и накрая се добавя символ за терминираща нула
std::cin >> str1;

char str2[129];
//четат се 128 символа от конзолата
//и накрая се добавя символ за терминираща нула
std::cin.getline(str2,129);
```

Ще използваме най-вече втория начин.

## Обхождане на низове

Можем да обхождаме низовете по същите начини, по които обхождахме и масиви.

Можем също така да се възползваме от терминиращата нула:

```c++
char const* str = "Pointers are cool!";
while (*str) {
  std::cout << *str;
}
```

*Забележка 1*: Терминиращата нула в ASCII таблицата има код 0. Това е много удобно за горния цикъл, тъй като терминиращата нула може да се сведе до булева променлива (логическа нула) и да се използва като условие за край на низа.

*Забележка 2*: Важно е да отбележим, че горното нямаше да е валиден начин за обхождане, ако нямахме различим символ (`'\0'`). Тогава цикълът щеше да бъде безкраен и щеше да изведе произволни стойностти от паметта (след самия низ).

## Размер на низ (масив vs. указател)

```c++
char str1[] = "FMI";
char const* str2 = "FMI";
assert(sizeof(str1) == 3); // 3*1 байта
assert(sizeof(str2) == 8); // 1*8 байта заради указателя
```

Допълнителен пример:

```c++
int arr1[] = {1,2,3,4};
int* arr2 = {1,2,3,4};
assert(sizeof(arr1) == 16); // 4*4 байта
assert(sizeof(arr2) == 8);  // 1*8 байта заради указателя
```