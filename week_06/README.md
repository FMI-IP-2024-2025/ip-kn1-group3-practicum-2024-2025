# Низове - 05.11.2024

### За решенията на следните задачи не е разрешено използването на `std::string`.

## Задача 1

Напишете програма, която приема низ от конзолата и прави всички в него букви малки. 

## Задача 2

Да се имплементират следните функции:

- `strlen(char const* str)` - връща дължината на `str`;
- `strcpy(char* dest, char const* source)` - копира низа `source` в `dest`;
- `strcat(char* dest, char const* source)` - конкатенира `dest` и `source` и запазва резултата в `dest`;
- `strcmp(char const* s1, char const* s2)`:
-- връща `-1`, ако `s1` е "по-малък" от `s2` (откъм лексикографска наредба);
-- `0`, ако са равни;
-- `1`, ако `s1` е "по-голям" от `s2`.

*Забележка 1*: За `strcpy` и `strcat` - погрижете се за случаите, в които `source` е с по-голям размер от `dest` и в които в `dest` няма достатъчно място за `source`.

*Забележка 2*: [Лексикографска наредба](https://en.wikipedia.org/wiki/Lexicographic_order) наричаме линейна (тотална) наредба между елементите на дадено множество - в нашия случай това е латинската азбука `a,b,...,z`. Наредбата между елементите е както следва: `a < b < c < d < ... < x < y < z`. Нека $s = s_1s_2...s_n$ и $t = t_1t_2...t_m$ са два низа.
- Два низа наричаме равни тогава и само тогава, когато $n = m$ и $s_i = t_i, \forall i \in \{1,...,n\}$.
- Казваме, че $s$ е по-малък от $t$, ако $n<m$ или $\exists i \in \{1,...,n\} : s_i < t_i$.
- Казваме, че $s$ е по-голям от $t$, ако $n>m$ или $\exists i \in \{1,...,m\} : s_i > t_i$.

*Забележка 2.1*: В `<cstring>` `stcmp` е имплементирана по по-различен начин. При нея дължините на низовете **нямат** значение, има значение само лексикографската наредба.

### След като сте стигнали дотук, вече можете да използвате по-горните функции наготово. Дефинирани са в `<cstring>`.

## Задача 3

Напишете програма, която приема като вход низ от конзолата, представящ число, и го превръща в число от тип `int`. За простота приемаме, че числото винаги ще бъде цяло. За целта да не се използват `atoi`, `atof` и др.

Примери:

```
"1234"  -> 1234
"0342"  -> 342
```

## Задача 4

Напишете програма, която приема като вход от конзолата низ с максимална дължина 1024 символа и извежда дали той е панграма.

*Забележка*: Панграма наричаме изречение, което съдържа всяка буква от азбуката.

```
Input:  The quick brown fox jumps over the lazy dog
Output: true
```

## Задача 5

Напишете програма, която приема два низа от конзолата и проверява дали те са анаграми.

*Забележка*: Два низа се наричат анаграми, ако съдържат едни и същи букви (и всяка една буква се среща един и същи брой пъти и в двата низа), независимо от реда, в който се срещат.

Примери:

```
Input: "deal" "lead"        Output: true
Input: "silent" "listen"    Output: true
Input: "still" "slit"       Output: false
```

## Задача 6

Напишете програма, която приема два низа и проверява дали вторият низ е подниз на първия.

*Забележка*: Подниз на даден низ наричаме последователност от символи, която се съдържа в оригиналния низ. В частност празният низ и самият низ също са поднизове на оригиналния.

Примери:

```
Input: "cater" "cat"     Output: true
Input: "time" "me"       Output: true
Input: "general" "rat"   Output: false
```

## Задача 7

Напишете програма, която приема низ и връща дължината на най-дългия подниз, който е и палиндром.

## Задача 8

Напишете програма, която приема низ и заменя всички срещания на числа с '#'.
Примери:
```
Input:  I have 12 cats
Output: I have # cats

Input:  nonzeronumbers0912cannotstartwith0 
Output: nonzeronumbers##cannotstartwith#
``` 

## Задача 9

Напишете програма, която приема като вход от конзолата низ с максимална дължина 1024 символа и го шифрова, използвайки шифърът на Цезар. Нека изместването на всяка от буквите е в интервала [-26;26].

*Забележка*: Шифърът на Цезар наричаме метод на шифроване, в който всяка буква се заменя само с една и съща друга буква. Например, ако срещнем буквата "е", се изместваме с 3 букви напред и получаваме буквата "и".
```
Input:  Hello, world!  // offset of 3
Output: Khoor, zruog!

Input:  Hello, world!  // offset of -3
Output: Ebiil, tloia!
``` 

<details> 
    <summary>Hints</summary>
    Какво би се случило, ако имаме буквата 'z' и изместване напред с една буква?
    <details>
        <summary>Hint</summary>
        >За да се справите с този проблем, използвайте оператора за деление с остатък. 
    </details>
    А ако изместваме назад? Как може да си осигурите,
     че буквите ви винаги ще са в даден интервал?
    <details>
        <summary>Hint</summary>
        >Прибавете числото 26.
    </details>

</details>

## Задача 10

Напишете програма, която приема схема (която ще бъде по-опростен вид на регулярен израз) и низ и извежда дали низът отговаря на схемата. Например за схемата:
```
Hello, world.
> Hello, world!  -> true
> Hello, world!! -> false
> Hello, world   -> false

I lo*ve FMI
> I love FMI         -> true
> I loooooooove FMI  -> true
> I lve FMI          -> false
```
където:
- `.` отговаря на който и да е един символ;
- `*` отговаря на произволен брой повтарящи се символи.

Приемаме, че няма да имаме escape sequences. Тоест, ако искаме да имаме `.` в програмата и тъй като сам по себе си символът ще бъде оценен като "специален", можем да го escape-нем, като напишем `/.`. С цел улеснение на задачата няма да правим това (макар че може и да се опитате да го направите).