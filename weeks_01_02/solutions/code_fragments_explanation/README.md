# Разяснения по кодовите фрагменти, разглеждани в час

### Малко по-систематизирани обяснения на кодовите фрагменти и особеностите при тях за тези, на които им е интересно 

1)
```c++
#include <iostream>
int main() {
  std::cout << (char)104 << (char)105 << (char)33;  // hi!
  return 0;
}
```

В програмирането представяме символите, използвайки числа. `char` е тип данни, който е с големина 1 байт (8 бита). Това означава, че стойностите, които приема, са 256 (2^8) на брой. По стандарт се използва т.нар. [ASCII таблица](https://en.cppreference.com/w/cpp/language/ascii#:~:text=ASCII%20Chart.%20The%20following%20chart%20contains%20all%20128%20ASCII%20decimal).
Когато изведем на конзолата променлива от тип `char`, получаваме символната репрезентация на числото, т.е. `104 -> 'h'`, `105 -> 'i'`, `33 -> '!'`.
`(char)104` се нарича преобразуване на типа на дадена променлива (type conversion/casting). Експлицитно задаваме, че искаме стойността 104 да се разглежда като стойност от тип `char`.

2)

```c++
#include <iostream>
int main() {
  char letter = 'K';
  letter += 'a' - 'A';
  std::cout << letter;  // k
  return 0;
}
```

Инициализираме променливата `letter` със стойността `'K' (75 в ASCII таблицата)`, след което прибавяме на пръв поглед странна стойност, която не изглежда да е число. Но нека припомним - символите са *числа*. Тоест, ние можем да извършваме аритметични операции с тях, използвайки поредния им номер в ASCII таблицата. `'a'` и `'A'` има съответно поредни номера 97 и 65 и разликата им е 32 (2^5 - степен на двойката, което всъщност позволява по-"лесното" пресмятане на подобни изчисления, използвайки bit shifting). След това към 75 (`'K'`) прибавяме 32 и получаваме 107 (`'k'`). Това е едно основно свойство, което ще използваме, когато учим низове.

3)

```c++
#include <iostream>
int main() {
  unsigned char a = 255;
  char b = a;
  std::cout << (int)b;
  return 0;
}
```

`unsigned` променливите са числа *без знак* - това означава, че те винаги са *неотрицателни* (тъй като включваме и 0). 
Ако експлицитно не укажем, че един тип данни е `unsigned`, по подразбиране той е `signed`. Принтирайки `b` на конзолата, виждаме, че има стойност -1 - това е, защото -1 и 255 имат едни същи битови репрезентации за `char`. 

4)
```c++
#include <iostream>
int main() {
  int num = -1;
  unsigned int unsignedNum = num;
  std::cout << unsignedNum << '\n';
  std::cout << unsignedNum+1;
  return 0;
}
```

Когато преобразуваме отрицателно число до `unsigned` тип, получаваме някакво голямо число. То не е случайно - това е `unsigned` числото със същата битова репрезентация като `signed` числото -1. Това също е и горната граница на `unsigned int`. Ако ви е интересно, може да видите как работи т.нар. *two's complement*.

Когато прибавим 1 към това число, се получава *integer overflow* - прибавяме 1 към число, чието битово представяне със състои само от единици. Всички битове се зануляват и имаме пренос на единица, която води до препълване.

5)
```c++
#include <iostream>
int main() {
  float a = 0.2;
  float b = 0.1;
  if (a+b == 0.3) {
    std::cout << "computers can do simple math, of course!";
  }
  return 0;
}
```

От реалния анализ знаем, че множеството на реалните числа е *неизброимо безкрайно*. Ако например имаме реалното число 2.999, как знаем кое число следва след него? Отговорът е, че не знаем. Очевидно не може това да е числото 3, тъй като 2.9999 е преди 3 и след 2.999 (сравняваме ги по големина). Типовете с плаваща запетая (`float` = 4 bytes; `double` = 8 bytes) могат да запазят в себе си само краен брой различни числа. Именно затова се случват неточности при аритметиката с тях. За да направим едно такова сравнение валидно, си въвеждаме някаква произволно малка *положителна* константа $\epsilon$ (епсилон). Идеята е, ако имаме някакво реално число `x` и си фиксираме интервал $(x-\epsilon,x+\epsilon)$, можем да кажем, че числата, които попадат в този интервал (неизброимо много), са *почти равни* на `x`. Например, за `x=3.124567` и `epsilon=0.00001` имаме интервала $(3.124557,3.1234577)$ и очевидно `3.123455789` попада в този интервал - т.е. то е *приблизително* `x`.

*Малко лирическо отклонение*: Формално, едно множество е *изброимо безкрайно*, ако същестува биекция между него и множеството на естествените числа - т.е. можем да "преброим" елементите на това *изброимо* множество (т.к. множеството на естествените числа е изброимо безкрайно само по себе си). Интуитивно казано, можем да намерим някакъв начин, по който да броим елементите на това множество и абсолютно винаги ще знаем кой е следващия елемент след текущия. Ако ви е интересно, може да разгледате по какви начини се изброяват елементите на множеството на целите числа и на множеството на рационалните числа.

6)

```c++
#include <iostream>
int main() {
  int a = 10;
  if (a = 1) {
    std::cout << a;
  }
  return 0;
}
```
Първо, нека припомним разликата между двата оператора `=` и `==`.
- `=` са нарича *оператор за присвояване*. Използваме го, когато искаме да дадем (присвоим) определна стойност на някоя променлива. Де факто той *връща* стойност (няма да задълбаваме, тъй като все още не сме говорили за референции).
- `==` е *оператор за равенство*. Ако двата операнда, над които действа, са равни, връща `true`. В противен случай, връща `false`.

Горният код ще се компилира и изпълни без грешка. Идеята е, че ще присвоим стойността `1` на променливата `a`, след което ще се оцени стойността на израза `a` (оценява се до стойността, която държи в себе си, т.е. `1`). Всяка стойност, различна от 0, се оценява като логическа *истина*. Само и единствено 0 се оценява до `false`.

7)

```c++
#include <iostream>
int main() {
  int a = 42;
  std::cout << (a == 42 && a/0);
  return 0;
}
```

Начинът, по който се оценява горният булев израз, е, че първо се оценява `a == 42`, което е истина. Тъй като истината е неутрален елемент спрямо коюнкцията (`true` не променя резултата, колкото и пъти да го прилагаме към някакъв израз), оценяваме и следващия израз `a/0`. Проблемът с това е, че делението на цели числа на нула е недефинирано поведение (всъщност можете да разделите число с плаваща запетая на 0 и да получите `+inf`/`-inf`).

8)

```c++
#include <iostream>
int main() {
  int a = 42;
  std::cout << (a == 42 || a/0);
  std::cout << (a == 41 && a/0);
  return 0;
}
```

В първия израз `a == 42` се оценява до истина и няма нужда да смятаме останалата част от израза, така че тук `a/0` няма да се изпълни.

Абсолютно аналогично и във втория израз - `a == 41` се оценява до `false` и останалото не се изпълнява.

9)

```c++
#include <iostream>
int main() {
  int a = 10, b = 0;
  if (!a) {
    std::cout << "a is not zero";
  }
  else if (!b) {
    std::cout << "b is zero";
  }
  return 0;
}
```

Числата в C++ могат да се третират като булеви стойности. Всяко число, различно от 0, се третира като истина. Само и единствено 0 се оценява до `false`.


10)

```c++
#include <iostream>
int main() {
  int a = 15;
  int b = (a -= 5) * (a += 4);
  std::cout << b;
  return 0;
}
```

Тук директно променяме стойността на променливата `a`. Това също е пример за недефинирано поведение. В зависимост от компилатора тук ще получите различни резултати (а някъде и предупреждения да не правите по-горното). Винаги е добре да бъдете експлицитни в промените, които правите по променливите.