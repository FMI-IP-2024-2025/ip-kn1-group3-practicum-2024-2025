# Динамична памет - 10.12.2024

## Какво ще изведат/до какво поведение ще доведат следните кодови фрагменти:

1.
```c++
int x = 10, y = 13;
int* const ptr = &x;
int const* cptr = &x;
*ptr = 11;
std::cout << *cptr;
*cptr = 12;
cptr = &y;
std::cout << *cptr;
ptr = &y;
```

2.
```c++
int foo(int& x) { return x++; }
int main() {
  int x = 3;
  std::cout << foo(x) << ' ' << x;
  std::cout << foo(x+1);
}
```

3.
```c++
int foo(int const& x) { return x++; }
int main() {
  int x = 3;
  std::cout << foo(x) << ' ' << x;
  std::cout << foo(x+1);
}
```

4.
```c++
short* foo() { return new short(2); }
int main() {
  foo();
}
```

5.
```c++
int* foo(int x) { return new int(x+2); }
int main() {
  foo(1) = 8;
  *foo(1) = 8;
  int* ptr = foo(1);
  *ptr = 8;
  delete ptr; 
}
```

6.
```c++
short* foo() {
  short* s = new short(2);
  delete s;
  return s;
}
int main() {
  short* s = foo();
  std::cout << *s;
}
```

7.
```c++
int* ptr = nullptr;
int** ptrptr = &ptr;
std::cout << *ptr;
std::cout << *ptrptr;
```

### Погрижете се заделената динамична памет в програмите ви да бъде адекватно освободена.

## Задача 1

Да се напише функция, която да разменя стойностите на две променливи. Напишете два варианта на функцията, използвайки указатели и псевдоними.

## Задача 2

Да се напише функция `void reverse(int* begin, int* end)`, която обръща елементите на масив. Началото на масива се сочи от `begin`, а края му - от `end`.

*Забележка*: Под край на масив ще разбираме същинския му край, т.е. указател към елемента на последния индекс в масива.

## Задача 3

Да се напише функция `int binarySearch(int* begin, int* end, int el)`, която имплементира алгоритъма за двоично търсене. Ако `el` не се среща в масива, да се върнe `-1`.

## Задача 4

Да се напишат функции, която по подадена квадратна матрица:

- извеждат на конзолата елементите на вторичния диагонал;

- извеждат на конзолата елементите под вторичния диагонал, обхождайки тази част от масива по диагонали.

Размерът на матрицата и елементите ѝ се въвеждат от конзолата.

Пример:

```c++
Вход: 3           Изход: 3 5 7
      1 2 3              
      4 5 6              6 8
      7 8 9              9
```

Горният изход е *примерен*. Вторичният диагонал може да бъде обходен и като `3 5 7`, и като `7 5 3`. Елементите под вторичния диагонал могат да се обходят по няколко различни начина: `6 8; 9`, `8 6; 9`, `9; 6 8`, `9; 8 6`.

## Задача 5

Да се напише програма, която приема число `n` като вход от конзолата и създава масив от **цели** числа с този размер. След това се въвеждат неограничен брой двойки индекс и стойност - тази стойност се записва на съответния индекс в масива. Въвеждането продължава, докато не се въведе невалиден индекс. Това позволява в масива да се появят "дупки" (неинициализирани стойности на определени индекси). Да се изведат елементите на този масив на конзолата, като при срещане на "дупка" да се изведе подходящо съобщение.

*Бонус*: Да се не заделя памет за допълнителен масив.

Пример:

```c++
Вход:  4             Изход: undefined
       1 12                 12
       3 0                  undefined
      -1 4                  0
//масивът има вида [?,12,?,7]
```

## Задача 6

Даден е масив с максимална големина 10 елемента. Напишете програма, в която потребителят въвежда числа или докато не въведе 10 положителни числа, или не въведе числото 0. За всяко число `n` в масива се заделя количество памет за нов масив `arr`, който като първи елемент има големината на `arr`, а останалите елементи в `arr` са `n` на брой. След въвеждането на тези <= 10 числа да се позволи на потребителя да въведе съответния брой елементи за всеки от подмасивите на оригиналния масив. След това тези масиви да се изведат на конзолата.

Пример:

```c++
Вход: 3 4 -12 1 0         Изход: 1 2 3
      1 2 3                      0 0 0 0
      0 0 0 0                    42
      42
```

## Задача 7

Да се напише функция `int insert(int*& arr, int size, int index, int elem)`, която вмъква стойността `elem` на индекс `index`. Функцията да връща новия размер на масива.

*Защо подаваме указателя по референция?*

## Задача 8

Да се напише функция `void split(char const* str, char** dest, char delim)`, която разделя `str` на множество от низове, които се записват в `dest`, спрямо разделителя `delim`.

Пример:
```c++
split("pointers$are$cool",dest,'$');
//~> dest == ["pointers","are","cool"]
```